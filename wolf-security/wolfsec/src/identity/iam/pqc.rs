//! Post-Quantum Cryptography (PQC) Integration
//!
//! Post-quantum cryptographic algorithms for quantum-resistant security.
//! Uses wolf pack principles for secure quantum-resistant operations.

use anyhow::{anyhow, Result};
use chrono::{Duration, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::Mutex;
use tracing::{debug, info};
use uuid::Uuid;

use crate::identity::iam::{AuthenticationMethod, AuthenticationResult, IAMConfig};

/// Supported post-quantum cryptographic primitives
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum PQCAlgorithm {
    /// CRYSTALS-Kyber (FIPS 203) - Level 1 (AES-128 equivalent)
    Kyber512,
    /// CRYSTALS-Kyber (FIPS 203) - Level 3 (AES-192 equivalent)
    Kyber768,
    /// CRYSTALS-Kyber (FIPS 203) - Level 5 (AES-256 equivalent)
    Kyber1024,
    /// CRYSTALS-Dilithium (FIPS 204) - Level 2
    Dilithium2,
    /// CRYSTALS-Dilithium (FIPS 204) - Level 3
    Dilithium3,
    /// CRYSTALS-Dilithium (FIPS 204) - Level 5
    Dilithium5,
    /// Falcon lattice-based signature scheme - 512-bit
    Falcon512,
    /// Falcon lattice-based signature scheme - 1024-bit
    Falcon1024,
    /// SPHINCS+ stateless hash-based signature scheme - 128-bit
    SphincsPlus128,
    /// SPHINCS+ stateless hash-based signature scheme - 192-bit
    SphincsPlus192,
    /// SPHINCS+ stateless hash-based signature scheme - 256-bit
    SphincsPlus256,
    /// FrodoKEM unstructured lattice-based KEM - Level 1
    Frodo640AES,
    /// FrodoKEM unstructured lattice-based KEM - Level 3
    Frodo976AES,
    /// FrodoKEM unstructured lattice-based KEM - Level 5
    Frodo1344AES,
}

/// A quantum-resistant cryptographic key pair consisting of public and private components
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PQCKeyPair {
    /// Unique internal identifier for the key pair
    pub id: Uuid,
    /// The specific PQC algorithm used by this key pair
    pub algorithm: PQCAlgorithm,
    /// Raw public key bytes
    pub public_key: Vec<u8>,
    /// Securely handles private key bytes
    pub private_key: Vec<u8>,
    /// When the key pair was generated
    pub created_at: chrono::DateTime<Utc>,
    /// Optional expiration date for the key pair
    pub expires_at: Option<chrono::DateTime<Utc>>,
    /// Authorized usage for this key pair
    pub key_usage: PQCKeyUsage,
    /// If false, the key pair cannot be used for new operations
    pub active: bool,
}

/// Defined capabilities and constraints for a PQC key pair
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum PQCKeyUsage {
    /// Key is intended for data encryption and decryption
    Encryption,
    /// Key is intended for digital signing and verification
    Signing,
    /// Key is intended for secure session key establishment
    KeyExchange,
    /// Key is authorized for both encryption and signing operations
    DualPurpose,
}

/// Container for data encrypted using PQC algorithms
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PQCData {
    /// The encrypted payload
    pub ciphertext: Vec<u8>,
    /// ID of the public key used for encryption
    pub public_key_id: Uuid,
    /// The algorithm used for the encryption process
    pub algorithm: PQCAlgorithm,
    /// Optional encrypted symmetric key in a hybrid KEM/DEM scheme
    pub encrypted_key: Option<Vec<u8>>,
    /// Cryptographic initialization vector
    pub iv: Option<Vec<u8>>,
    /// Message authentication tag for integrity verification
    pub auth_tag: Option<Vec<u8>>,
    /// When the ciphertext was generated
    pub created_at: chrono::DateTime<Utc>,
}

/// Cryptographic proof of identity and integrity generated by a PQC signature scheme
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PQCSignature {
    /// Unique identifier for the signature record
    pub id: Uuid,
    /// The cryptographic hash of the data that was signed
    pub data_hash: Vec<u8>,
    /// The raw signature bytes
    pub signature: Vec<u8>,
    /// ID of the key pair used to generate the signature
    pub signing_key_id: Uuid,
    /// The specific signature algorithm used
    pub algorithm: PQCAlgorithm,
    /// When the signature was generated
    pub signed_at: chrono::DateTime<Utc>,
    /// True if the signature has been successfully verified
    pub verified: bool,
}

/// Parameters and state for a quantum-resistant key exchange session
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PQCKeyExchange {
    /// Unique identifier for the exchange session
    pub id: Uuid,
    /// Exchange-specific public key bytes
    pub public_key: Vec<u8>,
    /// Derivable shared secret bytes (only populated during active derivation)
    pub shared_secret: Option<Vec<u8>>,
    /// The KEM algorithm used for the exchange
    pub algorithm: PQCAlgorithm,
    /// When the exchange session was initiated
    pub created_at: chrono::DateTime<Utc>,
    /// Time-to-live for the exchange session metadata
    pub expires_at: chrono::DateTime<Utc>,
}

/// Interface for post-quantum cryptographic primitives.
pub trait PQCProvider: Send + Sync {
    /// Dispatches key generation for a specific post-quantum algorithm.
    ///
    /// # Errors
    /// Returns an error if key generation fails or the algorithm is unsupported.
    fn generate_key_pair(&self, algorithm: PQCAlgorithm) -> Result<PQCKeyPair>;

    /// Encrypts a payload using a quantum-resistant scheme.
    ///
    /// # Errors
    /// Returns an error if encryption fails or the algorithm is unsupported.
    fn encrypt(&self, data: &[u8], public_key: &[u8], algorithm: PQCAlgorithm) -> Result<PQCData>;

    /// Recovers a payload using a quantum-resistant decryption scheme.
    ///
    /// # Errors
    /// Returns an error if decryption fails or the ciphertext is malformed.
    fn decrypt(&self, data: &PQCData, private_key: &[u8]) -> Result<Vec<u8>>;

    /// Generates a digital signature for bytes using a PQC scheme.
    ///
    /// # Errors
    /// Returns an error if signing fails or the algorithm is unsupported.
    fn sign(
        &self,
        data: &[u8],
        private_key: &[u8],
        algorithm: PQCAlgorithm,
    ) -> Result<PQCSignature>;

    /// Validates a quantum-resistant digital signature.
    ///
    /// # Errors
    /// Returns an error if verification logic fails.
    fn verify_signature(
        &self,
        data: &[u8],
        signature: &PQCSignature,
        public_key: &[u8],
    ) -> Result<bool>;

    /// Initializes a post-quantum key exchange session.
    ///
    /// # Errors
    /// Returns an error if generation fails.
    fn generate_key_exchange(&self, algorithm: PQCAlgorithm) -> Result<PQCKeyExchange>;

    /// Finalizes a key exchange and calculates the resulting shared secret.
    ///
    /// # Errors
    /// Returns an error if derivation fails.
    fn derive_shared_secret(
        &self,
        key_exchange: &PQCKeyExchange,
        private_key: &[u8],
    ) -> Result<Vec<u8>>;
}

/// Provider for CRYSTALS-Kyber post-quantum KEM.
pub struct KyberProvider;

impl PQCProvider for KyberProvider {
    fn generate_key_pair(&self, algorithm: PQCAlgorithm) -> Result<PQCKeyPair> {
        // In production, use actual Kyber implementation
        // This is a mock implementation for demonstration

        let key_size = match algorithm {
            PQCAlgorithm::Kyber512 => 1632,
            PQCAlgorithm::Kyber768 => 2400,
            PQCAlgorithm::Kyber1024 => 3168,
            _ => return Err(anyhow!("Invalid Kyber algorithm")),
        };

        let public_key = vec![0u8; key_size];
        let private_key = vec![1u8; key_size];

        Ok(PQCKeyPair {
            id: Uuid::new_v4(),
            algorithm,
            public_key,
            private_key,
            created_at: Utc::now(),
            expires_at: Some(Utc::now() + Duration::days(365)),
            key_usage: PQCKeyUsage::KeyExchange,
            active: true,
        })
    }

    fn encrypt(
        &self,
        _data: &[u8],
        _public_key: &[u8],
        _algorithm: PQCAlgorithm,
    ) -> Result<PQCData> {
        // Mock implementation
        Ok(PQCData {
            ciphertext: vec![2u8; 100],
            public_key_id: Uuid::new_v4(),
            algorithm: PQCAlgorithm::Kyber512,
            encrypted_key: Some(vec![3u8; 32]),
            iv: Some(vec![4u8; 16]),
            auth_tag: Some(vec![5u8; 16]),
            created_at: Utc::now(),
        })
    }

    fn decrypt(&self, _data: &PQCData, _private_key: &[u8]) -> Result<Vec<u8>> {
        // Mock implementation
        Ok(vec![6u8; 50])
    }

    fn sign(
        &self,
        _data: &[u8],
        _private_key: &[u8],
        _algorithm: PQCAlgorithm,
    ) -> Result<PQCSignature> {
        Err(anyhow!("Kyber does not support signing"))
    }

    fn verify_signature(
        &self,
        _data: &[u8],
        _signature: &PQCSignature,
        _public_key: &[u8],
    ) -> Result<bool> {
        Err(anyhow!("Kyber does not support signature verification"))
    }

    fn generate_key_exchange(&self, algorithm: PQCAlgorithm) -> Result<PQCKeyExchange> {
        let key_pair = self.generate_key_pair(algorithm.clone())?;

        Ok(PQCKeyExchange {
            id: Uuid::new_v4(),
            public_key: key_pair.public_key,
            shared_secret: None,
            algorithm,
            created_at: Utc::now(),
            expires_at: Utc::now() + Duration::hours(1),
        })
    }

    fn derive_shared_secret(
        &self,
        _key_exchange: &PQCKeyExchange,
        _private_key: &[u8],
    ) -> Result<Vec<u8>> {
        // Mock implementation
        Ok(vec![7u8; 32])
    }
}

/// Provider for CRYSTALS-Dilithium post-quantum signatures.
pub struct DilithiumProvider;

impl PQCProvider for DilithiumProvider {
    fn generate_key_pair(&self, algorithm: PQCAlgorithm) -> Result<PQCKeyPair> {
        // In production, use actual Dilithium implementation
        let key_size = match algorithm {
            PQCAlgorithm::Dilithium2 => 1312,
            PQCAlgorithm::Dilithium3 => 1952,
            PQCAlgorithm::Dilithium5 => 2592,
            _ => return Err(anyhow!("Invalid Dilithium algorithm")),
        };

        let public_key = vec![8u8; key_size];
        let private_key = vec![9u8; key_size];

        Ok(PQCKeyPair {
            id: Uuid::new_v4(),
            algorithm,
            public_key,
            private_key,
            created_at: Utc::now(),
            expires_at: Some(Utc::now() + Duration::days(365)),
            key_usage: PQCKeyUsage::Signing,
            active: true,
        })
    }

    fn encrypt(
        &self,
        _data: &[u8],
        _public_key: &[u8],
        _algorithm: PQCAlgorithm,
    ) -> Result<PQCData> {
        Err(anyhow!("Dilithium does not support encryption"))
    }

    fn decrypt(&self, _data: &PQCData, _private_key: &[u8]) -> Result<Vec<u8>> {
        Err(anyhow!("Dilithium does not support decryption"))
    }

    fn sign(
        &self,
        _data: &[u8],
        _private_key: &[u8],
        algorithm: PQCAlgorithm,
    ) -> Result<PQCSignature> {
        let key_pair = self.generate_key_pair(algorithm.clone())?;

        Ok(PQCSignature {
            id: Uuid::new_v4(),
            data_hash: vec![10u8; 32],
            signature: vec![11u8; 2420],
            signing_key_id: key_pair.id,
            algorithm,
            signed_at: Utc::now(),
            verified: true,
        })
    }

    fn verify_signature(
        &self,
        _data: &[u8],
        _signature: &PQCSignature,
        _public_key: &[u8],
    ) -> Result<bool> {
        // Mock implementation
        Ok(true)
    }

    fn generate_key_exchange(&self, _algorithm: PQCAlgorithm) -> Result<PQCKeyExchange> {
        Err(anyhow!("Dilithium does not support key exchange"))
    }

    fn derive_shared_secret(
        &self,
        _key_exchange: &PQCKeyExchange,
        _private_key: &[u8],
    ) -> Result<Vec<u8>> {
        Err(anyhow!(
            "Dilithium does not support shared secret derivation"
        ))
    }
}

/// Provider for SPHINCS+ stateless hash-based signatures.
pub struct SphincsPlusProvider;

impl PQCProvider for SphincsPlusProvider {
    fn generate_key_pair(&self, algorithm: PQCAlgorithm) -> Result<PQCKeyPair> {
        let key_size = match algorithm {
            PQCAlgorithm::SphincsPlus128 => 64,
            PQCAlgorithm::SphincsPlus192 => 96,
            PQCAlgorithm::SphincsPlus256 => 128,
            _ => return Err(anyhow!("Invalid SPHINCS+ algorithm")),
        };

        let public_key = vec![12u8; key_size];
        let private_key = vec![13u8; key_size];

        Ok(PQCKeyPair {
            id: Uuid::new_v4(),
            algorithm,
            public_key,
            private_key,
            created_at: Utc::now(),
            expires_at: Some(Utc::now() + Duration::days(365)),
            key_usage: PQCKeyUsage::Signing,
            active: true,
        })
    }

    fn encrypt(
        &self,
        _data: &[u8],
        _public_key: &[u8],
        _algorithm: PQCAlgorithm,
    ) -> Result<PQCData> {
        Err(anyhow!("SPHINCS+ does not support encryption"))
    }

    fn decrypt(&self, _data: &PQCData, _private_key: &[u8]) -> Result<Vec<u8>> {
        Err(anyhow!("SPHINCS+ does not support decryption"))
    }

    fn sign(
        &self,
        _data: &[u8],
        _private_key: &[u8],
        algorithm: PQCAlgorithm,
    ) -> Result<PQCSignature> {
        let key_pair = self.generate_key_pair(algorithm.clone())?;

        Ok(PQCSignature {
            id: Uuid::new_v4(),
            data_hash: vec![14u8; 32],
            signature: vec![15u8; 8000],
            signing_key_id: key_pair.id,
            algorithm,
            signed_at: Utc::now(),
            verified: true,
        })
    }

    fn verify_signature(
        &self,
        _data: &[u8],
        _signature: &PQCSignature,
        _public_key: &[u8],
    ) -> Result<bool> {
        // Mock implementation
        Ok(true)
    }

    fn generate_key_exchange(&self, _algorithm: PQCAlgorithm) -> Result<PQCKeyExchange> {
        Err(anyhow!("SPHINCS+ does not support key exchange"))
    }

    fn derive_shared_secret(
        &self,
        _key_exchange: &PQCKeyExchange,
        _private_key: &[u8],
    ) -> Result<Vec<u8>> {
        Err(anyhow!(
            "SPHINCS+ does not support shared secret derivation"
        ))
    }
}

/// Central orchestrator for all Post-Quantum Cryptographic operations, supporting multiple algorithms and providers
pub struct PQCManager {
    /// Registry of specialized providers mapped by algorithm type
    providers: Arc<Mutex<HashMap<PQCAlgorithm, Box<dyn PQCProvider>>>>,
    /// Local cache of generated or imported PQC key pairs
    key_pairs: Arc<Mutex<HashMap<Uuid, PQCKeyPair>>>,
    /// Record of issued digital signatures
    signatures: Arc<Mutex<HashMap<Uuid, PQCSignature>>>,
    /// Active key exchange sessions
    key_exchanges: Arc<Mutex<HashMap<Uuid, PQCKeyExchange>>>,
    /// Global IAM system configuration
    config: IAMConfig,
}

impl PQCManager {
    /// Initializes the manager and registers default providers for Kyber, Dilithium, and SPHINCS+.
    ///
    /// # Errors
    /// Returns an error if initialization fails.
    pub async fn new(config: IAMConfig) -> Result<Self> {
        info!("üîê Initializing PQC Manager");

        let mut providers: HashMap<PQCAlgorithm, Box<dyn PQCProvider>> = HashMap::new();

        // Add Kyber providers
        providers.insert(PQCAlgorithm::Kyber512, Box::new(KyberProvider));
        providers.insert(PQCAlgorithm::Kyber768, Box::new(KyberProvider));
        providers.insert(PQCAlgorithm::Kyber1024, Box::new(KyberProvider));

        // Add Dilithium providers
        providers.insert(PQCAlgorithm::Dilithium2, Box::new(DilithiumProvider));
        providers.insert(PQCAlgorithm::Dilithium3, Box::new(DilithiumProvider));
        providers.insert(PQCAlgorithm::Dilithium5, Box::new(DilithiumProvider));

        // Add SPHINCS+ providers
        providers.insert(PQCAlgorithm::SphincsPlus128, Box::new(SphincsPlusProvider));
        providers.insert(PQCAlgorithm::SphincsPlus192, Box::new(SphincsPlusProvider));
        providers.insert(PQCAlgorithm::SphincsPlus256, Box::new(SphincsPlusProvider));

        let manager = Self {
            providers: Arc::new(Mutex::new(providers)),
            key_pairs: Arc::new(Mutex::new(HashMap::new())),
            signatures: Arc::new(Mutex::new(HashMap::new())),
            key_exchanges: Arc::new(Mutex::new(HashMap::new())),
            config,
        };

        info!("‚úÖ PQC Manager initialized successfully");
        Ok(manager)
    }

    /// Dispatches key generation to a provider and persists the resulting key pair.
    ///
    /// # Errors
    /// Returns an error if the provider is not found or key generation fails.
    pub async fn generate_key_pair(&self, algorithm: PQCAlgorithm) -> Result<PQCKeyPair> {
        debug!("üîê Generating PQC key pair for algorithm: {:?}", algorithm);

        let providers = self.providers.lock().await;
        let provider = providers
            .get(&algorithm)
            .ok_or_else(|| anyhow!("PQC provider not found for algorithm: {:?}", algorithm))?;

        let key_pair = provider.generate_key_pair(algorithm)?;

        // Store key pair
        let mut key_pairs = self.key_pairs.lock().await;
        key_pairs.insert(key_pair.id, key_pair.clone());

        info!("‚úÖ PQC key pair generated: {}", key_pair.id);
        Ok(key_pair)
    }

    /// Encrypts context using the specified public key and PQC algorithm.
    ///
    /// # Errors
    /// Returns an error if the key is not found or encryption fails.
    pub async fn encrypt(
        &self,
        data: &[u8],
        public_key_id: Uuid,
        algorithm: PQCAlgorithm,
    ) -> Result<PQCData> {
        debug!("üîê Encrypting data with PQC algorithm: {:?}", algorithm);

        let key_pairs = self.key_pairs.lock().await;
        let key_pair = key_pairs
            .get(&public_key_id)
            .ok_or_else(|| anyhow!("Key pair not found: {}", public_key_id))?;

        let providers = self.providers.lock().await;
        let provider = providers
            .get(&algorithm)
            .ok_or_else(|| anyhow!("PQC provider not found for algorithm: {:?}", algorithm))?;

        let encrypted_data = provider.encrypt(data, &key_pair.public_key, algorithm.clone())?;

        // Store encrypted data
        let mut signatures = self.signatures.lock().await;
        let signature = PQCSignature {
            id: Uuid::new_v4(),
            data_hash: vec![], // Would be calculated from data
            signature: vec![], // Would be calculated
            signing_key_id: public_key_id,
            algorithm,
            signed_at: Utc::now(),
            verified: false,
        };
        signatures.insert(signature.id, signature);

        info!("‚úÖ Data encrypted with PQC");
        Ok(encrypted_data)
    }

    /// Recovers original data using a registered PQC private key.
    ///
    /// # Errors
    /// Returns an error if the key is not found or decryption fails.
    pub async fn decrypt(&self, data: &PQCData, private_key_id: Uuid) -> Result<Vec<u8>> {
        debug!("üîê Decrypting data with PQC");

        let key_pairs = self.key_pairs.lock().await;
        let key_pair = key_pairs
            .get(&private_key_id)
            .ok_or_else(|| anyhow!("Key pair not found: {}", private_key_id))?;

        let providers = self.providers.lock().await;
        let provider = providers
            .get(&data.algorithm)
            .ok_or_else(|| anyhow!("PQC provider not found for algorithm: {:?}", data.algorithm))?;

        let decrypted_data = provider.decrypt(data, &key_pair.private_key)?;

        info!("‚úÖ Data decrypted with PQC");
        Ok(decrypted_data)
    }

    /// Generates digital proof of identity for bytes using a PQC private key.
    ///
    /// # Errors
    /// Returns an error if the key is not found or signing fails.
    pub async fn sign(
        &self,
        data: &[u8],
        private_key_id: Uuid,
        algorithm: PQCAlgorithm,
    ) -> Result<PQCSignature> {
        debug!("üîê Signing data with PQC algorithm: {:?}", algorithm);

        let key_pairs = self.key_pairs.lock().await;
        let key_pair = key_pairs
            .get(&private_key_id)
            .ok_or_else(|| anyhow!("Key pair not found: {}", private_key_id))?;

        let providers = self.providers.lock().await;
        let provider = providers
            .get(&algorithm)
            .ok_or_else(|| anyhow!("PQC provider not found for algorithm: {:?}", algorithm))?;

        let signature = provider.sign(data, &key_pair.private_key, algorithm)?;

        // Store signature
        let mut signatures = self.signatures.lock().await;
        signatures.insert(signature.id, signature.clone());

        info!("‚úÖ Data signed with PQC");
        Ok(signature)
    }

    /// Validates a recorded PQC signature against original data using the associated public key.
    ///
    /// # Errors
    /// Returns an error if the signature or key is not found, or verification fails.
    pub async fn verify_signature(
        &self,
        data: &[u8],
        signature_id: Uuid,
    ) -> Result<PQCVerificationResult> {
        debug!("üîê Verifying PQC signature: {}", signature_id);

        let signatures = self.signatures.lock().await;
        let signature = signatures
            .get(&signature_id)
            .ok_or_else(|| anyhow!("Signature not found: {}", signature_id))?;

        let key_pairs = self.key_pairs.lock().await;
        let key_pair = key_pairs
            .get(&signature.signing_key_id)
            .ok_or_else(|| anyhow!("Key pair not found: {}", signature.signing_key_id))?;

        let providers = self.providers.lock().await;
        let provider = providers.get(&signature.algorithm).ok_or_else(|| {
            anyhow!(
                "PQC provider not found for algorithm: {:?}",
                signature.algorithm
            )
        })?;

        let is_valid = provider.verify_signature(data, signature, &key_pair.public_key)?;

        let verification_result = PQCVerificationResult {
            signature_id,
            valid: is_valid,
            algorithm: signature.algorithm.clone(),
            verified_at: Utc::now(),
            error_message: if is_valid {
                None
            } else {
                Some("Signature verification failed".to_string())
            },
        };

        info!("‚úÖ PQC signature verification completed: {}", is_valid);
        Ok(verification_result)
    }

    /// Creates a KEM-based key exchange session for establishing shared secrets.
    ///
    /// # Errors
    /// Returns an error if generation fails.
    pub async fn generate_key_exchange(&self, algorithm: PQCAlgorithm) -> Result<PQCKeyExchange> {
        debug!(
            "üîê Generating PQC key exchange for algorithm: {:?}",
            algorithm
        );

        let providers = self.providers.lock().await;
        let provider = providers
            .get(&algorithm)
            .ok_or_else(|| anyhow!("PQC provider not found for algorithm: {:?}", algorithm))?;

        let key_exchange = provider.generate_key_exchange(algorithm)?;

        // Store key exchange
        let mut key_exchanges = self.key_exchanges.lock().await;
        key_exchanges.insert(key_exchange.id, key_exchange.clone());

        info!("‚úÖ PQC key exchange generated: {}", key_exchange.id);
        Ok(key_exchange)
    }

    /// Finalizes a key exchange by extracting the shared secret bytes.
    ///
    /// # Errors
    /// Returns an error if the exchange or key is not found, or derivation fails.
    pub async fn derive_shared_secret(
        &self,
        key_exchange_id: Uuid,
        private_key_id: Uuid,
    ) -> Result<Vec<u8>> {
        debug!(
            "üîê Deriving shared secret for key exchange: {}",
            key_exchange_id
        );

        let key_exchanges = self.key_exchanges.lock().await;
        let key_exchange = key_exchanges
            .get(&key_exchange_id)
            .ok_or_else(|| anyhow!("Key exchange not found: {}", key_exchange_id))?;

        let key_pairs = self.key_pairs.lock().await;
        let key_pair = key_pairs
            .get(&private_key_id)
            .ok_or_else(|| anyhow!("Key pair not found: {}", private_key_id))?;

        let providers = self.providers.lock().await;
        let provider = providers.get(&key_exchange.algorithm).ok_or_else(|| {
            anyhow!(
                "PQC provider not found for algorithm: {:?}",
                key_exchange.algorithm
            )
        })?;

        let shared_secret = provider.derive_shared_secret(key_exchange, &key_pair.private_key)?;

        info!(
            "‚úÖ Shared secret derived for key exchange: {}",
            key_exchange_id
        );
        Ok(shared_secret)
    }

    /// Returns a summary snapshot of the PQC registry and item counts.
    pub async fn get_stats(&self) -> PQCStats {
        let key_pairs = self.key_pairs.lock().await;
        let signatures = self.signatures.lock().await;
        let key_exchanges = self.key_exchanges.lock().await;

        PQCStats {
            total_key_pairs: key_pairs.len(),
            total_signatures: signatures.len(),
            total_key_exchanges: key_exchanges.len(),
            last_update: Utc::now(),
        }
    }

    /// Scans the PQC registries and prunes items that have exceeded their time-to-live.
    ///
    /// # Errors
    /// Returns an error if cleanup fails.
    pub async fn cleanup_expired_items(&self) -> Result<()> {
        let now = Utc::now();
        let mut key_pairs = self.key_pairs.lock().await;
        let mut key_exchanges = self.key_exchanges.lock().await;

        // Clean up expired key pairs
        key_pairs.retain(|_, key_pair| {
            key_pair.expires_at.map_or(true, |exp| exp > now) && key_pair.active
        });

        // Clean up expired key exchanges
        key_exchanges.retain(|_, key_exchange| now < key_exchange.expires_at);

        info!("‚úÖ Cleaned up expired PQC items");
        Ok(())
    }

    /// Retrieves a complete PQC key pair snapshot from the registry.
    pub async fn get_key_pair(&self, key_id: Uuid) -> Option<PQCKeyPair> {
        let key_pairs = self.key_pairs.lock().await;
        key_pairs.get(&key_id).cloned()
    }

    /// Retrieves a specific PQC signature record from the registry.
    pub async fn get_signature(&self, signature_id: Uuid) -> Option<PQCSignature> {
        let signatures = self.signatures.lock().await;
        signatures.get(&signature_id).cloned()
    }
}

/// Comprehensive outcome of a quantum-resistant signature verification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PQCVerificationResult {
    /// Identifier of the signature targeted for verification
    pub signature_id: Uuid,
    /// True if the signature is cryptographically valid
    pub valid: bool,
    /// The algorithm used for the verification
    pub algorithm: PQCAlgorithm,
    /// Point in time when the verification occurred
    pub verified_at: chrono::DateTime<Utc>,
    /// Descriptive error if verification failed
    pub error_message: Option<String>,
}

/// Snapshot summary of the active Post-Quantum Cryptography infrastructure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PQCStats {
    /// Total number of distinct PQC key pairs managed
    pub total_key_pairs: usize,
    /// Total number of verified or pending signature records
    pub total_signatures: usize,
    /// Total number of KEM key exchange sessions
    pub total_key_exchanges: usize,
    /// Point in time when these statistics were calculated
    pub last_update: chrono::DateTime<Utc>,
}

impl From<PQCVerificationResult> for AuthenticationResult {
    fn from(pqc_result: PQCVerificationResult) -> Self {
        Self {
            id: Uuid::new_v4(),
            user_id: Uuid::new_v4(), // Would be extracted from signature context
            method: AuthenticationMethod::Certificate,
            success: pqc_result.valid,
            timestamp: pqc_result.verified_at,
            ip_address: "unknown".to_string(), // Would be extracted from request
            user_agent: "unknown".to_string(), // Would be extracted from request
            mfa_required: false,
            mfa_completed: true,
            session_id: None,
            error_message: pqc_result.error_message,
        }
    }
}
